//index version 28abril 2025 17:22 - Corregido y funcionando aun contesta con humano
const { webcrypto } = require('crypto'); // Usa 'require'
globalThis.crypto = webcrypto;

const { makeWASocket, useMultiFileAuthState, DisconnectReason } = require("@whiskeysockets/baileys");
const { Boom } = require("@hapi/boom");
const axios = require("axios");

// Definici√≥n de estructuras de datos
const conversacionesIniciadas = new Set(); // Almacena IDs de usuarios donde el bot inici√≥ la conversaci√≥n
const mensajesProcesados = new Map(); // Almacena IDs de mensajes procesados para evitar duplicados
const conversacionesControladasPorHumano = new Set(); // Almacena IDs de usuarios donde un humano tom√≥ el control

// Funci√≥n para verificar el estado de la conversaci√≥n (Esta funci√≥n no se usa actualmente, pero la mantengo si la necesitas)
function verificarEstadoConversacion(sender) {
    const esControlHumano = conversacionesControladasPorHumano.has(sender);
    console.log(`Estado conversaci√≥n ${sender}: ${esControlHumano ? 'Control Humano' : 'Control Bot'}`);
    return esControlHumano;
}

// Funci√≥n auxiliar para extraer texto limpio
function extractMessageText(msg) {
    return msg.message?.conversation ||
        msg.message?.extendedTextMessage?.text ||
        msg.message?.imageMessage?.caption ||
        null;
}

async function startBot() {
    const { state, saveCreds } = await useMultiFileAuthState("auth_info_baileys");
    const sock = makeWASocket({
        auth: state,
        printQRInTerminal: true, // Aseg√∫rate de que esto es lo que quieres para producci√≥n
        crypto: crypto
    });

    // Evento para guardar las credenciales
    sock.ev.on('creds.update', saveCreds);

    // Evento principal para manejar mensajes
    sock.ev.on("messages.upsert", async ({ messages }) => {
        const msg = messages[0];
        if (!msg.message || !msg.key.id) return;

        // Obtener informaci√≥n detallada del mensaje
        const sender = msg.key.remoteJid;
        const isMe = msg.key.fromMe; // Verificar si el mensaje lo enviaste t√∫ (el bot)
        const texto = extractMessageText(msg);

        // Verificar si el mensaje es de un grupo
        if (sender.endsWith('@g.us')) {
            console.log(` Mensaje de grupo ${sender} ignorado.`);
            return;
        }

        // L√≥gica para manejar comandos (humano/live, humano/offline) si se env√≠an desde el bot
        if (texto) {
            const comando = texto.trim().toLowerCase();
            // Si T√ö (el bot) env√≠as 'humano/live', marcar la conversaci√≥n como controlada por humano
            if (isMe && comando === 'humano/live') {
                if (!conversacionesControladasPorHumano.has(sender)) {
                    conversacionesControladasPorHumano.add(sender);
                    console.log(` üë§ [BOT] Comando 'humano/live' enviado a ${sender}. Conversaci√≥n marcada como controlada por humano.`);
                } else {
                    console.log(` üë§ [BOT] Comando 'humano/live' enviado a ${sender}, pero la conversaci√≥n ya estaba marcada.`);
                }
                // NOTA: Si este es el trigger, la l√≥gica de PERSISTENCIA (Redis) debe guardar este estado.
                return; // Detener el procesamiento del bot para este mensaje (ya que es un comando interno)
            } else if (isMe && comando === 'humano/offline') {
                // Si T√ö (el bot) env√≠as 'humano/offline', desmarcar la conversaci√≥n
                if (conversacionesControladasPorHumano.has(sender)) {
                    conversacionesControladasPorHumano.delete(sender);
                    console.log(` ü§ñ [BOT] Comando 'humano/offline' enviado a ${sender}. Conversaci√≥n desmarcada del control humano.`);
                } else {
                    console.log(` ü§ñ [BOT] Comando 'humano/offline' enviado a ${sender}, pero la conversaci√≥n no estaba marcada como controlada.`);
                }
                 // NOTA: Si este es el trigger, la l√≥gica de PERSISTENCIA (Redis) debe eliminar este estado.
                return; // Detener el procesamiento del bot para este mensaje (ya que es un comando interno)
            }
        }


        // Verificar si la conversaci√≥n ya est√° marcada como controlada por un humano
        // NOTA: Esta verificaci√≥n usar√° PERSISTENCIA (Redis) en el futuro.
        if (conversacionesControladasPorHumano.has(sender)) {
            console.log(` ‚úã Conversaci√≥n con ${sender} controlada por humano. El bot no responder√°.`);
            // Podr√≠as a√±adir aqu√≠ l√≥gica para notificar al agente si el usuario env√≠a un mensaje
            return; // El bot no responde si est√° en modo humano
        }

        // Verificar si la conversaci√≥n fue iniciada por el bot
        // NOTA: La l√≥gica actual solo responde si el bot INICI√ì la conversaci√≥n O si el mensaje lo env√≠a el BOT.
        // Si quieres que el bot responda si el USUARIO inicia la conversaci√≥n, necesitas a√±adir el JID a 'conversacionesIniciadas'
        // en el primer mensaje que recibes de un nuevo usuario.
        if (!conversacionesIniciadas.has(sender) && !isMe) {
            console.log(` üîá Ignorando mensaje de ${sender}: Conversaci√≥n no iniciada por el bot.`);
            return; // Ignorar si no la inici√≥ el bot y no la enviaste t√∫ (el bot)
        }


        // Resto de la l√≥gica del bot para responder a mensajes NO controlados por humano
        if (!texto || texto.trim().length < 2) return; // Ignorar mensajes muy cortos o vac√≠os
        const textoLimpio = texto.trim().toLowerCase();
        const palabras = textoLimpio.split(/\s+/);
        // Ajuste: Permite la palabra "humano" aunque sean menos de 3 palabras, si esa es tu detecci√≥n manual.
        if (palabras.length < 3 && !textoLimpio.includes("humano")) return;

        // Evitar procesar mensajes duplicados (en memoria, se resetea al reiniciar)
        if (mensajesProcesados.has(msg.key.id)) return;
        mensajesProcesados.set(msg.key.id, Date.now());


        // >>> Bloque TRY...CATCH...FINALLY Corregido <<<
        try {
            // >> MODIFICACI√ìN AQU√ç: Env√≠a el sender (JID) en el campo 'from' <<
            // Esto es crucial para que el backend Python gestione el historial por usuario
            const response = await axios.post("http://127.0.0.1:5000/gpt", {
                from: sender, // <--- ¬°Campo 'from' agregado!
                message: texto
            });
            const gptReply = response.data.reply || "ü§ñ Lo siento, no entend√≠ la pregunta.";
            await sock.sendMessage(sender, { text: gptReply });
        } // <-- CIERRE CORRECTO DEL BLOQUE 'try'
        catch (error) { // <-- INICIO CORRECTO DEL BLOQUE 'catch'
            console.error(" ‚ùå Error al comunicarse con GPT:", error.message);
            // >> LOGS DE DEPURACI√ìN ADICIONALES AQU√ç <<
            // Ayudan a entender por qu√© falla la comunicaci√≥n con Python
            if (error.response && error.response.status) { // Verifica si hay una respuesta HTTP y un status (ej. 400, 500)
                console.error(`    Estado HTTP: ${error.response.status}`);
                if (error.response.data) { // Si hay datos en la respuesta de error de Python
                    console.error("    Datos de la respuesta de error:", error.response.data); // √ötil para ver tracebacks de errores 500
                }
            } else if (error.code) { // Si es un error de red como ECONNREFUSED, ETIMEOUT, etc.
                console.error(`    C√≥digo de error: ${error.code}`); // Indica problemas de conexi√≥n o que Python no est√° corriendo
            }
            // << FIN DE LOGS ADICIONALES >>
            // Env√≠a un mensaje de fallback al usuario si hubo un error al comunicarse con la IA
            await sock.sendMessage(sender, { text: "‚ö†Ô∏è No se pudo obtener respuesta de la IA." });
        } // <-- CIERRE CORRECTO DEL BLOQUE 'catch'
        finally { // <-- INICIO CORRECTO DEL BLOQUE 'finally'. ¬°Esta l√≠nea debe estar en su lugar! PM2 la reporta en la l√≠nea 111 con este c√≥digo.
            // Limpia el mensaje del Map de procesados despu√©s de un tiempo
            setTimeout(() => mensajesProcesados.delete(msg.key.id), 30000);
        } // <-- CIERRE CORRECTO DEL BLOQUE 'finally'

    }); // <-- CIERRE CORRECTO DEL MANEJADOR messages.upsert

    // Evento para manejar desconexiones de Baileys
    sock.ev.on('connection.update', (update) => {
        const { connection, lastDisconnect } = update;
        if (connection === 'close') {
            console.error('Conexi√≥n perdida:', lastDisconnect?.error?.output?.statusCode);
            // Si la conexi√≥n se cierra inesperadamente (no por QR o logout), intenta salir para que PM2 reinicie
            if (lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut &&
                lastDisconnect?.error?.output?.statusCode !== DisconnectReason.connectionClosed) { // A√±adido DisconnectReason.connectionClosed
                console.log('Intentando reiniciar el proceso...');
                process.exit(1); // Salir para que PM2 reinicie el bot
            } else {
                 console.log('Conexi√≥n cerrada intencionalmente o limpia. No reiniciar autom√°ticamente.');
            }
        } else if (connection === 'open') {
            console.log('‚úÖ ¬°Bot conectado exitosamente!');
            // Aqu√≠ podr√≠as a√±adir l√≥gica para marcar conversaciones como no controladas por humano si el bot se reconecta despu√©s de una interrupci√≥n larga,
            // pero con Redis ser√≠a mejor gestionar esto.
        }
         console.log('Estado de conexi√≥n:', update); // Loggea todas las actualizaciones de conexi√≥n
    });

    // Manejar eventos de QR (solo si printQRInTerminal es true)
    sock.ev.on('qr', (qr) => {
        console.log('Nuevo QR recibido:', qr); // Muestra el QR en la terminal si es necesario escanear
    });


} // <-- CIERRE CORRECTO DE LA FUNCI√ìN startBot

// Iniciar el bot al ejecutar el script
startBot();